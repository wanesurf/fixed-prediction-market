"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTypedObjectParams = exports.getParamsTypeAnnotation = exports.getPropertySignatureFromProp = exports.getPropertyType = exports.getType = exports.getTypeInfo = exports.detectType = exports.getTypeOrRef = exports.getTypeFromRef = exports.getResponseType = void 0;
const t = __importStar(require("@babel/types"));
const case_1 = require("case");
const babel_1 = require("./babel");
function getResponseType(context, underscoreName) {
    const methodName = (0, case_1.camel)(underscoreName);
    return (0, case_1.pascal)(context.contract?.responses?.[underscoreName]?.title
        ??
            // after v1.1 is adopted, we can deprecate this and require the above response
            `${methodName}Response`);
}
exports.getResponseType = getResponseType;
;
const getTypeStrFromRef = ($ref) => {
    if ($ref?.startsWith('#/definitions/')) {
        return $ref.replace('#/definitions/', '');
    }
    throw new Error('what is $ref: ' + $ref);
};
const getTypeFromRef = ($ref) => {
    return t.tsTypeReference(t.identifier(getTypeStrFromRef($ref)));
};
exports.getTypeFromRef = getTypeFromRef;
const getArrayTypeFromRef = ($ref) => {
    return t.tsArrayType((0, exports.getTypeFromRef)($ref));
};
const getTypeOrRef = (obj) => {
    if (obj.$ref) {
        return (0, exports.getTypeFromRef)(obj.$ref);
    }
    else if (typeof obj.type === 'string') {
        return (0, exports.getType)(obj.type);
    }
    else if (Array.isArray(obj.type)) {
        // Handle array of types by creating a union type
        const types = obj.type.map(t => (0, exports.getType)(t));
        return t.tsUnionType(types);
    }
    else {
        throw new Error('Type definition not supported or missing: ' + JSON.stringify(obj));
    }
};
exports.getTypeOrRef = getTypeOrRef;
const getArrayTypeFromItems = (context, items) => {
    if (Array.isArray(items)) {
        // if (context.options.types.itemsUseTuples === true) {
        // Using the modified method with tsTupleType
        // return t.tsArrayType(
        // t.tsTupleType(items.map(item => getTypeOrRef(item)))
        // );
        // } else {
        // Using the original method with nested arrays
        if (items.length > 0 && items[0].type === 'array') {
            return getArrayTypeFromItems(context, items[0]);
        }
        return items.length > 0 ? t.tsArrayType(t.tsArrayType((0, exports.getTypeOrRef)(items[0]))) : t.tsArrayType(t.tsArrayType(t.tsAnyKeyword()));
        // }
    }
    else {
        const detect = (0, exports.detectType)(items.type);
        if (detect.type === 'array') {
            if (Array.isArray(items.items)) {
                return t.tsArrayType(t.tsArrayType((0, exports.getTypeOrRef)(items.items[0])));
            }
            else if (items.items) {
                return t.tsArrayType(getArrayTypeFromItems(context, items.items));
            }
            else {
                // Handle the case where items.items is undefined for array types
                return t.tsArrayType(t.tsAnyKeyword());
            }
        }
        return t.tsArrayType((0, exports.getType)(detect.type));
    }
};
const detectType = (type) => {
    let optional = false;
    let theType = '';
    if (Array.isArray(type)) {
        if (type.length !== 2) {
            throw new Error('[getType(array length)] case not handled by transpiler. contact maintainers.');
        }
        const [nullableType, nullType] = type;
        if (nullType !== 'null') {
            throw new Error('[getType(null)] case not handled by transpiler. contact maintainers.');
        }
        theType = nullableType;
        optional = true;
    }
    else {
        theType = type;
    }
    return {
        type: theType,
        optional
    };
};
exports.detectType = detectType;
const getTypeInfo = (context, info) => {
    let type = undefined;
    let optional = undefined;
    // Handle nullable types using 'anyOf' schema
    if (Array.isArray(info.anyOf)) {
        if (info.anyOf.length !== 2) {
            throw new Error('case not handled by transpiler. contact maintainers.');
        }
        const [nullableType, nullType] = info.anyOf;
        if (nullType?.type !== 'null') {
            throw new Error('[nullableType.type]: case not handled by transpiler. contact maintainers.');
        }
        if (!nullableType?.$ref) {
            if (nullableType.title) {
                type = t.tsTypeReference(t.identifier(nullableType.title));
            }
            else {
                throw new Error('[nullableType.title] case not handled by transpiler. contact maintainers.');
            }
        }
        else {
            type = (0, exports.getTypeFromRef)(nullableType.$ref);
        }
        optional = true;
    }
    else if (typeof info.type === 'string') {
        // Process type when it's explicitly defined
        if (info.type === 'array') {
            if (typeof info.items === 'object' && !Array.isArray(info.items)) {
                if (info.items.$ref) {
                    type = getArrayTypeFromRef(info.items.$ref);
                }
                else if (info.items.title) {
                    type = t.tsArrayType(t.tsTypeReference(t.identifier(info.items.title)));
                }
                else if (info.items.type) {
                    type = getArrayTypeFromItems(context, info.items);
                }
                else {
                    throw new Error('[info.items] case not handled by transpiler. contact maintainers.');
                }
                // type = getArrayTypeFromItems(context, info.items);
            }
            else {
                if (Array.isArray(info.items)) {
                    type = getArrayTypeFromItems(context, info.items);
                }
                else {
                    throw new Error('[info.items] case not handled by transpiler. contact maintainers.');
                }
            }
        }
        else {
            const detect = (0, exports.detectType)(info.type);
            type = (0, exports.getType)(detect.type);
            optional = detect.optional;
        }
    }
    else if (Array.isArray(info.type)) {
        // Handle multiple types, typically nullable types
        if (info.type.length !== 2) {
            throw new Error('please report this to maintainers (field type): ' + JSON.stringify(info, null, 2));
        }
        const [nullableType, nullType] = info.type;
        if (nullType !== 'null') {
            throw new Error('please report this to maintainers (field type): ' + JSON.stringify(info, null, 2));
        }
        if (nullableType === 'array' && typeof info.items === 'object' && !Array.isArray(info.items)) {
            if (info.items.type) {
                const detect = (0, exports.detectType)(info.items.type);
                if (detect.type === 'array') {
                    type = t.tsArrayType(getArrayTypeFromItems(context, info.items));
                }
                else {
                    type = t.tsArrayType((0, exports.getType)(detect.type));
                }
                optional = detect.optional;
            }
            else if (info.items.$ref) {
                type = getArrayTypeFromRef(info.items.$ref);
            }
            else if (info.items.type) {
                type = getArrayTypeFromItems(context, info.items);
            }
            else {
                throw new Error('[info.items] case not handled by transpiler. contact maintainers.');
            }
        }
        else {
            const detect = (0, exports.detectType)(nullableType);
            optional = detect.optional;
            if (detect.type === 'array') {
                type = getArrayTypeFromItems(context, info.items);
            }
            else {
                type = (0, exports.getType)(detect.type);
            }
        }
        optional = true; // Ensure optional is set for nullable types
    }
    return {
        type,
        optional
    };
};
exports.getTypeInfo = getTypeInfo;
const getType = (type) => {
    switch (type) {
        case 'string':
            return t.tsStringKeyword();
        case 'boolean':
            return t.tSBooleanKeyword();
        case 'integer':
            return t.tsNumberKeyword();
        case 'null':
            return t.tsNullKeyword();
        case 'number':
            return t.tsNumberKeyword();
        default:
            throw new Error('contact maintainers [unknown type]: ' + type);
    }
};
exports.getType = getType;
const getPropertyType = (context, schema, prop) => {
    const props = schema.properties ?? {};
    let info = props[prop];
    let type = null;
    let optional = !schema.required?.includes(prop);
    if (info.allOf && info.allOf.length === 1) {
        info = info.allOf[0];
    }
    if (typeof info.$ref === 'string') {
        type = (0, exports.getTypeFromRef)(info.$ref);
    }
    const typeInfo = (0, exports.getTypeInfo)(context, info);
    if (typeof typeInfo.optional !== 'undefined') {
        optional = typeInfo.optional;
    }
    if (typeof typeInfo.type !== 'undefined') {
        type = typeInfo.type;
    }
    if (!type) {
        throw new Error('cannot find type for ' + JSON.stringify(info));
    }
    if (schema.required?.includes(prop)) {
        optional = false;
    }
    return { type, optional };
};
exports.getPropertyType = getPropertyType;
function getPropertySignatureFromProp(context, jsonschema, prop, camelize) {
    if (jsonschema.properties[prop].type === 'object') {
        if (jsonschema.properties[prop].title) {
            return (0, babel_1.propertySignature)(camelize ? (0, case_1.camel)(prop) : prop, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(jsonschema.properties[prop].title))));
        }
        else {
            throw new Error('getPropertySignatureFromProp() contact maintainer');
        }
    }
    if (Array.isArray(jsonschema.properties[prop].allOf)) {
        const isOptional = !jsonschema.required?.includes(prop);
        const unionTypes = jsonschema.properties[prop].allOf.map(el => {
            if (el.title)
                return el.title;
            if (el.$ref)
                return getTypeStrFromRef(el.$ref);
            return el.type;
        }).filter(a => typeof a === 'string');
        // ONLY SUPPORT string types for now!
        // e.g. NOT supporting nullable types or type: string[] yet
        // @ts-ignore:next-line
        const uniqUnionTypes = [...new Set(unionTypes)];
        if (uniqUnionTypes.length === 1) {
            return (0, babel_1.propertySignature)(camelize ? (0, case_1.camel)(prop) : prop, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(uniqUnionTypes[0]))), isOptional);
        }
        else {
            return (0, babel_1.propertySignature)(camelize ? (0, case_1.camel)(prop) : prop, t.tsTypeAnnotation(t.tsUnionType(uniqUnionTypes.map(typ => t.tsTypeReference(t.identifier(typ))))), isOptional);
        }
    }
    else if (Array.isArray(jsonschema.properties[prop].oneOf)) {
        const isOptional = !jsonschema.required?.includes(prop);
        const unionTypes = jsonschema.properties[prop].oneOf.map(el => {
            if (el.title)
                return el.title;
            if (el.$ref)
                return getTypeStrFromRef(el.$ref);
            return el.type;
        }).filter(a => typeof a === 'string');
        // ONLY SUPPORT string types for now!
        // e.g. NOT supporting nullable types or type: string[] yet
        const uniqUnionTypes = [...new Set(unionTypes)];
        if (uniqUnionTypes.length === 1) {
            return (0, babel_1.propertySignature)(camelize ? (0, case_1.camel)(prop) : prop, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(uniqUnionTypes[0]))), isOptional);
        }
        else {
            return (0, babel_1.propertySignature)(camelize ? (0, case_1.camel)(prop) : prop, t.tsTypeAnnotation(t.tsUnionType(uniqUnionTypes.map(typ => t.tsTypeReference(t.identifier(typ))))), isOptional);
        }
    }
    try {
        (0, exports.getPropertyType)(context, jsonschema, prop);
    }
    catch (e) {
        console.log(e);
        console.log(JSON.stringify(jsonschema, null, 2), prop);
    }
    const { type, optional } = (0, exports.getPropertyType)(context, jsonschema, prop);
    return (0, babel_1.propertySignature)(camelize ? (0, case_1.camel)(prop) : prop, t.tsTypeAnnotation(type), optional);
}
exports.getPropertySignatureFromProp = getPropertySignatureFromProp;
const getParamsTypeAnnotation = (context, jsonschema, camelize = true) => {
    const keys = Object.keys(jsonschema.properties ?? {});
    if (!keys.length && jsonschema.$ref) {
        return t.tsTypeAnnotation((0, exports.getTypeFromRef)(jsonschema.$ref));
    }
    if (!keys.length)
        return undefined;
    const typedParams = keys.map(prop => getPropertySignatureFromProp(context, jsonschema, prop, camelize));
    return t.tsTypeAnnotation(t.tsTypeLiteral(
    // @ts-ignore:next-line
    [
        ...typedParams
    ]));
};
exports.getParamsTypeAnnotation = getParamsTypeAnnotation;
const createTypedObjectParams = (context, jsonschema, camelize = true) => {
    const keys = Object.keys(jsonschema.properties ?? {});
    if (!keys.length) {
        // is there a ref?
        if (jsonschema.$ref) {
            const obj = context.refLookup(jsonschema.$ref);
            // If there is a oneOf, then we need to create a type for it
            if (obj?.oneOf) {
                // the actual type of the ref
                const refType = jsonschema.$ref.split('/').pop();
                const refName = (0, case_1.camel)(refType);
                const id = t.identifier(refName);
                id.typeAnnotation = t.tsTypeAnnotation(t.tsTypeReference(t.identifier(refType)));
                return id;
            }
            else if (obj) {
                return (0, exports.createTypedObjectParams)(context, obj, camelize);
            }
        }
        // no results...
        return;
    }
    const params = keys.map(prop => {
        return t.objectProperty(camelize ? t.identifier((0, case_1.camel)(prop)) : t.identifier(prop), camelize ? t.identifier((0, case_1.camel)(prop)) : t.identifier(prop), false, true);
    });
    const obj = t.objectPattern([
        ...params
    ]);
    obj.typeAnnotation = (0, exports.getParamsTypeAnnotation)(context, jsonschema, camelize);
    return obj;
};
exports.createTypedObjectParams = createTypedObjectParams;
