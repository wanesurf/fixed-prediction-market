"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickTypeReference = exports.omitTypeReference = exports.parameterizedTypeReference = exports.typeRefOrUnionWithUndefined = exports.optionalConditionalExpression = exports.memberExpressionOrIdentifierSnake = exports.memberExpressionOrIdentifier = exports.getFieldDimensionality = exports.importAminoMsg = exports.importAs = exports.importStmt = exports.shorthandProperty = exports.FieldTypeAsts = exports.arrayTypeNDimensions = exports.recursiveNamespace = exports.arrowFunctionExpression = exports.classProperty = exports.classDeclaration = exports.abstractClassDeclaration = exports.promiseTypeAnnotation = exports.typedIdentifier = exports.bindMethod = exports.callExpression = exports.tsObjectPattern = exports.tsPropertySignature = exports.getMessageProperties = exports.tsTypeOperator = exports.identifier = exports.propertySignature = void 0;
const t = __importStar(require("@babel/types"));
const case_1 = require("case");
const ref_1 = require("./ref");
// t.TSPropertySignature - kind?
const propertySignature = (name, typeAnnotation, optional = false) => {
    return {
        type: 'TSPropertySignature',
        key: t.identifier(name),
        kind: 'get',
        typeAnnotation,
        optional
    };
};
exports.propertySignature = propertySignature;
const identifier = (name, typeAnnotation, optional = false) => {
    const type = t.identifier(name);
    type.typeAnnotation = typeAnnotation;
    type.optional = optional;
    return type;
};
exports.identifier = identifier;
const tsTypeOperator = (typeAnnotation, operator) => {
    const obj = t.tsTypeOperator(typeAnnotation);
    obj.operator = operator;
    return obj;
};
exports.tsTypeOperator = tsTypeOperator;
const getMessageProperties = (msg) => {
    let results = [];
    let objs = [];
    if (msg.anyOf) {
        objs = msg.anyOf;
    }
    else if (msg.oneOf) {
        objs = msg.oneOf;
    }
    else if (msg.allOf) {
        objs = msg.allOf;
    }
    for (const obj of objs) {
        if (obj.properties) {
            results.push(obj);
        }
        else {
            if (obj.$ref) {
                const ref = (0, ref_1.refLookup)(obj.$ref, msg);
                const refProps = (0, exports.getMessageProperties)(ref);
                results = [...results, ...refProps];
            }
        }
    }
    return results;
};
exports.getMessageProperties = getMessageProperties;
const tsPropertySignature = (key, typeAnnotation, optional) => {
    const obj = t.tsPropertySignature(key, typeAnnotation);
    obj.optional = optional;
    return obj;
};
exports.tsPropertySignature = tsPropertySignature;
const tsObjectPattern = (properties, typeAnnotation) => {
    const obj = t.objectPattern(properties);
    obj.typeAnnotation = typeAnnotation;
    return obj;
};
exports.tsObjectPattern = tsObjectPattern;
const callExpression = (callee, _arguments, typeParameters) => {
    const callExpr = t.callExpression(callee, _arguments);
    callExpr.typeParameters = typeParameters;
    return callExpr;
};
exports.callExpression = callExpression;
const bindMethod = (name) => {
    return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier(name)), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier(name)), t.identifier('bind')), [
        t.thisExpression()
    ])));
};
exports.bindMethod = bindMethod;
const typedIdentifier = (name, typeAnnotation, optional = false) => {
    const type = t.identifier(name);
    type.typeAnnotation = typeAnnotation;
    type.optional = optional;
    return type;
};
exports.typedIdentifier = typedIdentifier;
const promiseTypeAnnotation = (name) => {
    return t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([
        t.tsTypeReference(t.identifier(name))
    ])));
};
exports.promiseTypeAnnotation = promiseTypeAnnotation;
const abstractClassDeclaration = (name, body, implementsExressions = [], superClass = null) => {
    const declaration = (0, exports.classDeclaration)(name, body, implementsExressions, superClass);
    declaration.abstract = true;
    return declaration;
};
exports.abstractClassDeclaration = abstractClassDeclaration;
const classDeclaration = (name, body, implementsExressions = [], superClass = null) => {
    const declaration = t.classDeclaration(t.identifier(name), superClass, t.classBody(body));
    if (implementsExressions.length) {
        declaration.implements = implementsExressions;
    }
    return declaration;
};
exports.classDeclaration = classDeclaration;
const classProperty = (name, typeAnnotation = null, isReadonly = false, isStatic = false, noImplicitOverride = false, useDeclareKeyword = false) => {
    const prop = t.classProperty(t.identifier(name));
    if (isReadonly)
        prop.readonly = true;
    if (isStatic)
        prop.static = true;
    if (typeAnnotation)
        prop.typeAnnotation = typeAnnotation;
    if (noImplicitOverride)
        prop.override = true;
    if (useDeclareKeyword)
        prop.declare = true;
    return prop;
};
exports.classProperty = classProperty;
const arrowFunctionExpression = (params, body, returnType, isAsync = false) => {
    const func = t.arrowFunctionExpression(params, body, isAsync);
    if (returnType)
        func.returnType = returnType;
    return func;
};
exports.arrowFunctionExpression = arrowFunctionExpression;
const recursiveNamespace = (names, moduleBlockBody) => {
    if (!names || !names.length)
        return moduleBlockBody;
    const name = names.pop();
    const body = [
        t.exportNamedDeclaration(t.tsModuleDeclaration(t.identifier(name), t.tsModuleBlock((0, exports.recursiveNamespace)(names, moduleBlockBody))))
    ];
    return body;
};
exports.recursiveNamespace = recursiveNamespace;
const arrayTypeNDimensions = (body, n) => {
    if (!n)
        return t.tsArrayType(body);
    return t.tsArrayType((0, exports.arrayTypeNDimensions)(body, n - 1));
};
exports.arrayTypeNDimensions = arrayTypeNDimensions;
exports.FieldTypeAsts = {
    string: () => {
        return t.tsStringKeyword();
    },
    array: (type) => {
        const result = exports.FieldTypeAsts[type]();
        return t.tsArrayType(result);
    },
    Duration: () => {
        return t.tsTypeReference(t.identifier('Duration'));
    },
    Height: () => {
        return t.tsTypeReference(t.identifier('Height'));
    },
    Coin: () => {
        return t.tsTypeReference(t.identifier('Coin'));
    },
    Long: () => {
        return t.tsTypeReference(t.identifier('Long'));
    }
};
const shorthandProperty = (prop) => {
    return t.objectProperty(t.identifier(prop), t.identifier(prop), false, true);
};
exports.shorthandProperty = shorthandProperty;
const importStmt = (names, path) => {
    return t.importDeclaration(names.map(name => t.importSpecifier(t.identifier(name), t.identifier(name))), t.stringLiteral(path));
};
exports.importStmt = importStmt;
const importAs = (name, importAs, importPath) => {
    return t.importDeclaration([
        t.importSpecifier(t.identifier(importAs), t.identifier(name))
    ], t.stringLiteral(importPath));
};
exports.importAs = importAs;
const importAminoMsg = () => {
    return (0, exports.importStmt)(['AminoMsg'], '@cosmjs/amino');
};
exports.importAminoMsg = importAminoMsg;
const getFieldDimensionality = (field) => {
    let typeName = field.type;
    const isArray = typeName.endsWith('[]');
    let dimensions = 0;
    if (isArray) {
        dimensions = typeName.match(/\[\]/g).length - 1;
        typeName = typeName.replace(/\[\]/g, '');
    }
    return {
        typeName,
        dimensions,
        isArray
    };
};
exports.getFieldDimensionality = getFieldDimensionality;
const memberExpressionOrIdentifier = (names) => {
    if (names.length === 1) {
        return t.identifier(names[0]);
    }
    if (names.length === 2) {
        const [b, a] = names;
        return t.memberExpression(t.identifier(a), t.identifier(b));
    }
    const [name, ...rest] = names;
    return t.memberExpression((0, exports.memberExpressionOrIdentifier)(rest), t.identifier(name));
};
exports.memberExpressionOrIdentifier = memberExpressionOrIdentifier;
const memberExpressionOrIdentifierSnake = (names) => {
    if (names.length === 1) {
        return t.identifier((0, case_1.snake)(names[0]));
    }
    if (names.length === 2) {
        const [b, a] = names;
        return t.memberExpression(t.identifier((0, case_1.snake)(a)), t.identifier((0, case_1.snake)(b)));
    }
    const [name, ...rest] = names;
    return t.memberExpression((0, exports.memberExpressionOrIdentifierSnake)(rest), t.identifier((0, case_1.snake)(name)));
};
exports.memberExpressionOrIdentifierSnake = memberExpressionOrIdentifierSnake;
/**
 * If optional, return a conditional, otherwise just the expression
 */
const optionalConditionalExpression = (test, expression, alternate, optional = false) => {
    return optional
        ? t.conditionalExpression(test, expression, alternate)
        : expression;
};
exports.optionalConditionalExpression = optionalConditionalExpression;
const typeRefOrUnionWithUndefined = (identifier, optional = false) => {
    const typeReference = t.tsTypeReference(identifier);
    return optional
        ? t.tsUnionType([
            typeReference,
            t.tsUndefinedKeyword()
        ])
        : typeReference;
};
exports.typeRefOrUnionWithUndefined = typeRefOrUnionWithUndefined;
const parameterizedTypeReference = (identifier, from, omit) => {
    return t.tsTypeReference(t.identifier(identifier), t.tsTypeParameterInstantiation([
        from,
        typeof omit === 'string'
            ? t.tsLiteralType(t.stringLiteral(omit))
            : t.tsUnionType(omit.map(o => t.tsLiteralType(t.stringLiteral(o))))
    ]));
};
exports.parameterizedTypeReference = parameterizedTypeReference;
/**
 * omitTypeReference(t.tsTypeReference(t.identifier('Cw4UpdateMembersMutation'),),'args').....
 * Omit<Cw4UpdateMembersMutation, 'args'>
 */
const omitTypeReference = (from, omit) => {
    return (0, exports.parameterizedTypeReference)('Omit', from, omit);
};
exports.omitTypeReference = omitTypeReference;
const pickTypeReference = (from, pick) => {
    return (0, exports.parameterizedTypeReference)('Pick', from, pick);
};
exports.pickTypeReference = pickTypeReference;
