"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createReactQueryHookInterface = exports.createReactQueryMutationHook = exports.createReactQueryMutationHooks = exports.createReactQueryMutationArgsInterface = exports.createReactQueryHook = exports.createReactQueryHooks = void 0;
const t = __importStar(require("@babel/types"));
const case_1 = require("case");
const utils_1 = require("../utils");
const babel_1 = require("../utils/babel");
const constants_1 = require("../utils/constants");
const types_1 = require("../utils/types");
const createReactQueryHooks = ({ context, queryMsg, contractName, QueryClient }) => {
    const options = context.options.reactQuery;
    const genericQueryInterfaceName = `${(0, case_1.pascal)(contractName)}ReactQuery`;
    const underscoreNames = (0, utils_1.getMessageProperties)(queryMsg).map((schema) => Object.keys(schema.properties)[0]);
    const body = [];
    const queryKeysName = `${(0, case_1.camel)(contractName)}QueryKeys`;
    if (options.queryKeys) {
        body.push(createReactQueryKeys({
            context,
            queryKeysName,
            camelContractName: (0, case_1.camel)(contractName),
            underscoreNames
        }));
    }
    const queryMsgs = (0, utils_1.getMessageProperties)(queryMsg).map((schema) => {
        // list_voters
        const underscoreName = Object.keys(schema.properties)[0];
        // listVoters
        const methodName = (0, case_1.camel)(underscoreName);
        // Cw3FlexMultisigListVotersQuery
        const hookParamsTypeName = `${(0, case_1.pascal)(contractName)}${(0, case_1.pascal)(methodName)}Query`;
        // useCw3FlexMultisigListVotersQuery
        const hookName = `use${hookParamsTypeName}`;
        // listVotersResponse
        const responseType = (0, types_1.getResponseType)(context, underscoreName);
        // cw3FlexMultisigListVoters
        const getterKey = (0, case_1.camel)(`${contractName}${(0, case_1.pascal)(methodName)}`);
        const jsonschema = schema.properties[underscoreName];
        return {
            underscoreName,
            methodName,
            hookParamsTypeName,
            hookName,
            responseType,
            getterKey,
            jsonschema
        };
    });
    const queryFactoryName = `${(0, case_1.camel)(contractName)}Queries`;
    if (options.queryFactory) {
        body.push(createReactQueryFactory({
            context,
            queryFactoryName,
            queryKeysName,
            queryMsgs
        }));
    }
    body.push(createReactQueryHookGenericInterface({
        context,
        QueryClient,
        genericQueryInterfaceName
    }));
    body.push(...queryMsgs.reduce((m, { methodName, hookParamsTypeName, hookName, responseType, getterKey, jsonschema }) => {
        return [
            (0, exports.createReactQueryHookInterface)({
                context,
                hookParamsTypeName,
                responseType,
                queryInterfaceName: genericQueryInterfaceName,
                QueryClient,
                jsonschema
            }),
            (0, exports.createReactQueryHook)({
                context,
                methodName,
                hookName,
                hookParamsTypeName,
                queryKeysName,
                responseType,
                hookKeyName: getterKey,
                jsonschema
            }),
            ...m
        ];
    }, []));
    return body;
};
exports.createReactQueryHooks = createReactQueryHooks;
function buildQueryFn(methodName, jsonschema, options) {
    const keys = Object.keys(jsonschema.properties ?? {});
    let args = [];
    if (keys.length) {
        args = [
            t.objectExpression([
                ...keys.map((prop) => {
                    return t.objectProperty(t.identifier((0, case_1.camel)(prop)), t.memberExpression(t.identifier('args'), t.identifier((0, case_1.camel)(prop))));
                })
            ])
        ];
    }
    const rejectInvalidClient = t.callExpression(t.memberExpression(t.identifier('Promise'), t.identifier('reject')), [
        t.newExpression(t.identifier('Error'), [
            t.stringLiteral('Invalid client')
        ])
    ]);
    return t.arrowFunctionExpression([], (0, babel_1.optionalConditionalExpression)(t.identifier('client'), t.callExpression(t.memberExpression(t.identifier('client'), t.identifier(methodName)), args), rejectInvalidClient, options.optionalClient), false);
}
const ENABLED_QUERY_OPTION = t.objectProperty(t.identifier('enabled'), t.logicalExpression('&&', t.unaryExpression('!', t.unaryExpression('!', t.identifier('client'))), t.conditionalExpression(
// explicitly check for undefined
t.binaryExpression('!=', t.optionalMemberExpression(t.identifier('options'), t.identifier('enabled'), false, true), t.identifier('undefined')), t.memberExpression(t.identifier('options'), t.identifier('enabled')), t.booleanLiteral(true))));
function buildQueryOptions(options) {
    return options.optionalClient
        ? t.objectExpression([
            t.spreadElement(t.identifier('options')),
            t.objectProperty(t.identifier('enabled'), t.logicalExpression('&&', t.unaryExpression('!', t.unaryExpression('!', t.identifier('client'))), t.conditionalExpression(
            // explicitly check for undefined
            t.binaryExpression('!=', t.optionalMemberExpression(t.identifier('options'), t.identifier('enabled'), false, true), t.identifier('undefined')), t.memberExpression(t.identifier('options'), t.identifier('enabled')), t.booleanLiteral(true))))
        ])
        : t.identifier('options');
}
const createReactQueryHook = ({ context, hookName, hookParamsTypeName, responseType, hookKeyName, queryKeysName, methodName, jsonschema }) => {
    context.addUtil('useQuery');
    context.addUtil('UseQueryOptions');
    const options = context.options.reactQuery;
    const keys = Object.keys(jsonschema.properties ?? {});
    let props = ['client', 'options'];
    if (keys.length) {
        props = ['client', 'args', 'options'];
    }
    const selectResponseGenericTypeName = GENERIC_SELECT_RESPONSE_NAME;
    const queryFunctionDeclaration = t.functionDeclaration(t.identifier(hookName), [
        (0, utils_1.tsObjectPattern)([
            ...props.map((prop) => {
                return t.objectProperty(t.identifier(prop), t.identifier(prop), false, true);
            })
        ], t.tsTypeAnnotation(t.tsTypeReference(t.identifier(hookParamsTypeName), t.tsTypeParameterInstantiation([
            t.tsTypeReference(t.identifier(selectResponseGenericTypeName))
        ]))))
    ], t.blockStatement([
        t.returnStatement((0, utils_1.callExpression)(t.identifier('useQuery'), [
            generateUseQueryQueryKey({
                hookKeyName,
                queryKeysName,
                methodName,
                props,
                options
            }),
            buildQueryFn(methodName, jsonschema, options),
            buildQueryOptions(options)
        ], t.tsTypeParameterInstantiation([
            t.tsTypeReference(t.identifier(responseType)),
            t.tsTypeReference(t.identifier('Error')),
            t.tsTypeReference(t.identifier(selectResponseGenericTypeName))
        ])))
    ]));
    // Add the TData type parameters
    queryFunctionDeclaration.typeParameters = t.tsTypeParameterDeclaration([
        t.tsTypeParameter(undefined, t.tSTypeReference(t.identifier(responseType)), selectResponseGenericTypeName)
    ]);
    return t.exportNamedDeclaration(queryFunctionDeclaration);
};
exports.createReactQueryHook = createReactQueryHook;
/**
 * Example:
```
 export interface Cw721RevokeMutation {
  client: Cw721Client;
  msg: {
    spender: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
```
 */
const createReactQueryMutationArgsInterface = ({ context, ExecuteClient, mutationHookParamsTypeName, useMutationTypeParameter, jsonschema }) => {
    const typedUseMutationOptions = t.tsTypeReference(t.identifier('UseMutationOptions'), useMutationTypeParameter);
    const body = [
        (0, utils_1.tsPropertySignature)(t.identifier('client'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier(ExecuteClient))), false)
    ];
    const msgType = (0, utils_1.createTypedObjectParams)(context, jsonschema)?.typeAnnotation;
    if (msgType) {
        body.push(t.tsPropertySignature(t.identifier('msg'), 
        // @ts-ignore
        msgType));
    }
    context.addUtil('StdFee');
    context.addUtil('Coin');
    const optionalArgs = t.tsPropertySignature(t.identifier('args'), t.tsTypeAnnotation(
    // @ts-ignore:next-line
    t.tsTypeLiteral([
        (0, babel_1.propertySignature)('fee', constants_1.OPTIONAL_FEE_PARAM.typeAnnotation, true),
        (0, babel_1.propertySignature)('memo', constants_1.OPTIONAL_MEMO_PARAM.typeAnnotation, true),
        (0, babel_1.propertySignature)('funds', utils_1.OPTIONAL_FUNDS_PARAM.typeAnnotation, true)
    ])));
    optionalArgs.optional = true;
    body.push(optionalArgs);
    return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(mutationHookParamsTypeName), null, [], t.tsInterfaceBody(body)));
};
exports.createReactQueryMutationArgsInterface = createReactQueryMutationArgsInterface;
const createReactQueryMutationHooks = ({ context, execMsg, contractName, ExecuteClient }) => {
    // merge the user options with the defaults
    return (0, utils_1.getMessageProperties)(execMsg).reduce((m, schema) => {
        // update_members
        const execMethodUnderscoreName = Object.keys(schema.properties)[0];
        // updateMembers
        const execMethodName = (0, case_1.camel)(execMethodUnderscoreName);
        // Cw20UpdateMembersMutation
        const mutationHookParamsTypeName = `${(0, case_1.pascal)(contractName)}${(0, case_1.pascal)(execMethodName)}Mutation`;
        // useCw20UpdateMembersMutation
        const mutationHookName = `use${mutationHookParamsTypeName}`;
        const jsonschema = schema.properties[execMethodUnderscoreName];
        const properties = jsonschema.properties ?? {};
        // TODO: there should be a better way to do this
        const hasMsg = !!(Object.keys(properties)?.length || jsonschema?.$ref);
        // <ExecuteResult, Error, Cw4UpdateMembersMutation>
        const useMutationTypeParameter = generateMutationTypeParameter(context, mutationHookParamsTypeName);
        return [
            (0, exports.createReactQueryMutationArgsInterface)({
                context,
                mutationHookParamsTypeName,
                ExecuteClient,
                jsonschema,
                useMutationTypeParameter
            }),
            (0, exports.createReactQueryMutationHook)({
                context,
                execMethodName,
                mutationHookName,
                mutationHookParamsTypeName,
                hasMsg,
                useMutationTypeParameter
            }),
            ...m
        ];
    }, []);
};
exports.createReactQueryMutationHooks = createReactQueryMutationHooks;
/**
 * Generates the mutation type parameter. If args exist, we use a pick. If not, we just return the params type.
 */
const generateMutationTypeParameter = (context, mutationHookParamsTypeName) => {
    context.addUtil('ExecuteResult');
    return t.tsTypeParameterInstantiation([
        // Data
        t.tSTypeReference(t.identifier('ExecuteResult')),
        // Error
        t.tsTypeReference(t.identifier('Error')),
        // Variables
        t.tsTypeReference(t.identifier(mutationHookParamsTypeName))
    ]);
};
/**
 *
 * Example:
```
export const useCw4UpdateMembersMutation = ({ client, options }: Omit<Cw4UpdateMembersMutation, 'args'>) =>
  useMutation<ExecuteResult, Error, Pick<Cw4UpdateMembersMutation, 'args'>>(
    ({ args }) => client.updateMembers(args),
    options
  )
```
 */
const createReactQueryMutationHook = ({ context, mutationHookName, mutationHookParamsTypeName, execMethodName, useMutationTypeParameter, hasMsg }) => {
    context.addUtil('useMutation');
    context.addUtil('UseMutationOptions');
    const useMutationFunctionArgs = [(0, babel_1.shorthandProperty)('client')];
    if (hasMsg)
        useMutationFunctionArgs.push((0, babel_1.shorthandProperty)('msg'));
    useMutationFunctionArgs.push(t.objectProperty(t.identifier('args'), t.assignmentPattern(t.objectPattern([
        (0, babel_1.shorthandProperty)('fee'),
        (0, babel_1.shorthandProperty)('memo'),
        (0, babel_1.shorthandProperty)('funds')
    ]), t.objectExpression([]))));
    return t.exportNamedDeclaration(t.functionDeclaration(t.identifier(mutationHookName), [
        (0, utils_1.identifier)('options', t.tsTypeAnnotation((0, babel_1.omitTypeReference)(t.tsTypeReference(t.identifier('UseMutationOptions'), useMutationTypeParameter), 'mutationFn')), true)
    ], t.blockStatement([
        t.returnStatement((0, utils_1.callExpression)(t.identifier('useMutation'), [
            t.arrowFunctionExpression([t.objectPattern(useMutationFunctionArgs)], t.callExpression(t.memberExpression(t.identifier('client'), t.identifier(execMethodName)), (hasMsg ? [t.identifier('msg')] : []).concat([
                t.identifier('fee'),
                t.identifier('memo'),
                t.identifier('funds')
            ])), false // not async
            ),
            t.identifier('options')
        ], useMutationTypeParameter))
    ])));
};
exports.createReactQueryMutationHook = createReactQueryMutationHook;
function createReactQueryKeys({ context, queryKeysName, camelContractName, underscoreNames }) {
    const options = context.options.reactQuery;
    const contractAddressTypeAnnotation = t.tsTypeAnnotation(options.optionalClient
        ? t.tsUnionType([t.tsStringKeyword(), t.tsUndefinedKeyword()])
        : t.tSStringKeyword());
    return t.exportNamedDeclaration(t.variableDeclaration('const', [
        t.variableDeclarator(t.identifier(queryKeysName), t.objectExpression([
            // 1: contract
            t.objectProperty(t.identifier('contract'), t.tSAsExpression(t.arrayExpression([
                t.objectExpression([
                    t.objectProperty(t.identifier('contract'), t.stringLiteral(camelContractName))
                ])
            ]), t.tSTypeReference(t.identifier('const')))),
            // 2: address
            t.objectProperty(t.identifier('address'), t.arrowFunctionExpression([(0, utils_1.identifier)('contractAddress', contractAddressTypeAnnotation)], t.tSAsExpression(t.arrayExpression([
                t.objectExpression([
                    // 1
                    t.spreadElement(t.memberExpression(t.memberExpression(t.identifier(queryKeysName), t.identifier('contract')), t.numericLiteral(0), true // computed
                    )),
                    t.objectProperty(t.identifier('address'), t.identifier('contractAddress'))
                ])
            ]), t.tSTypeReference(t.identifier('const'))))),
            // 3: methods
            ...underscoreNames.map((underscoreMethodName) => t.objectProperty(
            // key id is the camel method name
            t.identifier((0, case_1.camel)(underscoreMethodName)), t.arrowFunctionExpression([
                (0, utils_1.identifier)('contractAddress', contractAddressTypeAnnotation),
                (0, utils_1.identifier)('args', 
                // Record<string, unknown>
                t.tSTypeAnnotation(t.tsTypeReference(t.identifier('Record'), t.tsTypeParameterInstantiation([
                    t.tsStringKeyword(),
                    t.tsUnknownKeyword()
                ]))), true // optional
                )
            ], t.tSAsExpression(t.arrayExpression([
                t.objectExpression([
                    //...cw3FlexMultisigQueryKeys.address(contractAddress)[0]
                    t.spreadElement(t.memberExpression(t.callExpression(t.memberExpression(t.identifier(queryKeysName), t.identifier('address')), [t.identifier('contractAddress')]), t.numericLiteral(0), true // computed
                    )),
                    // method: list_voters
                    t.objectProperty(t.identifier('method'), t.stringLiteral(underscoreMethodName)),
                    // args
                    (0, babel_1.shorthandProperty)('args')
                ])
            ]), t.tSTypeReference(t.identifier('const'))))))
        ]))
    ]));
}
function createReactQueryFactory({ context, queryFactoryName, queryKeysName, queryMsgs }) {
    const options = context.options.reactQuery;
    return t.exportNamedDeclaration(t.variableDeclaration('const', [
        t.variableDeclarator(t.identifier(queryFactoryName), t.objectExpression([
            ...queryMsgs.map(({ methodName, hookParamsTypeName, responseType, jsonschema }) => {
                const hasArgs = Object.keys(jsonschema.properties ?? {}).length > 0;
                const methodQueryOptionsFn = t.arrowFunctionExpression([
                    (0, utils_1.tsObjectPattern)([
                        (0, babel_1.shorthandProperty)('client'),
                        ...(hasArgs ? [(0, babel_1.shorthandProperty)('args')] : []),
                        (0, babel_1.shorthandProperty)('options')
                    ], t.tsTypeAnnotation(t.tsTypeReference(t.identifier(hookParamsTypeName), t.tsTypeParameterInstantiation([
                        t.tsTypeReference(t.identifier(GENERIC_SELECT_RESPONSE_NAME))
                    ]))))
                ], t.objectExpression([
                    // 1: queryKey
                    t.objectProperty(t.identifier('queryKey'), t.callExpression(t.memberExpression(t.identifier(queryKeysName), t.identifier(methodName)), [
                        t.optionalMemberExpression(t.identifier('client'), t.identifier('contractAddress'), false, true),
                        ...(hasArgs ? [t.identifier('args')] : [])
                    ])),
                    // 2: queryFn
                    t.objectProperty(t.identifier('queryFn'), buildQueryFn(methodName, jsonschema, options)),
                    // 3: spread options
                    t.spreadElement(t.identifier('options')),
                    // 4. enabled
                    ENABLED_QUERY_OPTION
                ]));
                methodQueryOptionsFn.typeParameters =
                    t.tsTypeParameterDeclaration([
                        t.tsTypeParameter(undefined, t.tsTypeReference(t.identifier(responseType)), GENERIC_SELECT_RESPONSE_NAME)
                    ]);
                methodQueryOptionsFn.returnType = t.tsTypeAnnotation(t.tsTypeReference(t.identifier('UseQueryOptions'), t.tsTypeParameterInstantiation([
                    t.tsTypeReference(t.identifier(responseType)),
                    t.tsTypeReference(t.identifier('Error')),
                    t.tsTypeReference(t.identifier(GENERIC_SELECT_RESPONSE_NAME))
                ])));
                return t.objectProperty(
                // key id is the camel method name
                t.identifier((0, case_1.camel)(methodName)), methodQueryOptionsFn);
            })
        ]))
    ]));
}
const GENERIC_SELECT_RESPONSE_NAME = 'TData';
function createReactQueryHookGenericInterface({ context, QueryClient, genericQueryInterfaceName }) {
    const options = context.options.reactQuery;
    const genericResponseTypeName = 'TResponse';
    context.addUtil('UseQueryOptions');
    // UseQueryOptions<TResponse, Error, TData>,
    const typedUseQueryOptions = t.tsTypeReference(t.identifier('UseQueryOptions'), t.tsTypeParameterInstantiation([
        t.tsTypeReference(t.identifier(genericResponseTypeName)),
        t.tsTypeReference(t.identifier('Error')),
        t.tsTypeReference(t.identifier(GENERIC_SELECT_RESPONSE_NAME))
    ]));
    const body = [
        (0, utils_1.tsPropertySignature)(t.identifier('client'), t.tsTypeAnnotation(options.optionalClient
            ? t.tsUnionType([
                t.tsTypeReference(t.identifier(QueryClient)),
                t.tsUndefinedKeyword()
            ])
            : t.tsTypeReference(t.identifier(QueryClient))), false),
        (0, utils_1.tsPropertySignature)(t.identifier('options'), t.tsTypeAnnotation(options.version === 'v4'
            ? t.tSIntersectionType([
                (0, babel_1.omitTypeReference)(typedUseQueryOptions, "'queryKey' | 'queryFn' | 'initialData'"),
                t.tSTypeLiteral([
                    t.tsPropertySignature(t.identifier('initialData?'), t.tsTypeAnnotation(t.tsUndefinedKeyword()))
                ])
            ])
            : typedUseQueryOptions), true)
    ];
    return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(genericQueryInterfaceName), t.tsTypeParameterDeclaration([
        // 1: TResponse
        t.tsTypeParameter(undefined, undefined, genericResponseTypeName),
        // 2: TData
        t.tsTypeParameter(undefined, t.tSTypeReference(t.identifier(genericResponseTypeName)), GENERIC_SELECT_RESPONSE_NAME)
    ]), [], t.tSInterfaceBody(body)));
}
const createReactQueryHookInterface = ({ context, QueryClient, hookParamsTypeName, queryInterfaceName, responseType, jsonschema }) => {
    // merge the user options with the defaults
    const options = context.options.reactQuery;
    const body = [];
    const props = getProps(context, jsonschema);
    if (props.length) {
        body.push(t.tsPropertySignature(t.identifier('args'), t.tsTypeAnnotation(
        // @ts-ignore:next-line
        t.tsTypeLiteral(props))));
    }
    return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(hookParamsTypeName), t.tsTypeParameterDeclaration([
        t.tSTypeParameter(undefined, undefined, GENERIC_SELECT_RESPONSE_NAME)
    ]), [
        t.tSExpressionWithTypeArguments(t.identifier(queryInterfaceName), t.tsTypeParameterInstantiation([
            // 1: response
            t.tsTypeReference(t.identifier(responseType)),
            // 2: select generic
            t.tSTypeReference(t.identifier(GENERIC_SELECT_RESPONSE_NAME))
        ]))
    ], t.tsInterfaceBody(body)));
};
exports.createReactQueryHookInterface = createReactQueryHookInterface;
const getProps = (context, jsonschema) => {
    const keys = Object.keys(jsonschema.properties ?? {});
    if (!keys.length)
        return [];
    return keys.map((prop) => {
        const { type, optional } = (0, types_1.getPropertyType)(context, jsonschema, prop);
        return (0, babel_1.propertySignature)(context.options.reactQuery.camelize ? (0, case_1.camel)(prop) : prop, t.tsTypeAnnotation(type), optional);
    });
};
const generateUseQueryQueryKey = ({ hookKeyName, queryKeysName, methodName, props, options }) => {
    const { optionalClient, queryKeys } = options;
    const hasArgs = props.includes('args');
    const contractAddressExpression = t.optionalMemberExpression(t.identifier('client'), t.identifier('contractAddress'), false, optionalClient);
    if (queryKeys) {
        const callArgs = [contractAddressExpression];
        if (hasArgs)
            callArgs.push(t.identifier('args'));
        return t.callExpression(t.memberExpression(t.identifier(queryKeysName), t.identifier((0, case_1.camel)(methodName))), callArgs);
    }
    const queryKey = [
        t.stringLiteral(hookKeyName),
        contractAddressExpression
    ];
    if (hasArgs) {
        queryKey.push(t.callExpression(t.memberExpression(t.identifier('JSON'), t.identifier('stringify')), [t.identifier('args')]));
    }
    return t.arrayExpression(queryKey);
};
