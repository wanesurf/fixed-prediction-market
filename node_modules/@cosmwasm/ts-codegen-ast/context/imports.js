"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelativePath = exports.getImportStatements = exports.convertUtil = exports.convertUtilsToImportList = exports.UTIL_HELPERS = exports.UTILS = void 0;
const t = __importStar(require("@babel/types"));
const path_1 = require("path");
const utils_1 = require("../utils");
const makeReactQuerySwitch = (varName) => {
    return (context) => {
        switch (context.options.reactQuery.version) {
            case 'v4':
                return {
                    type: 'import',
                    path: '@tanstack/react-query',
                    name: varName
                };
            case 'v3':
            default:
                return {
                    type: 'import',
                    path: 'react-query',
                    name: varName
                };
        }
    };
};
exports.UTILS = {
    selectorFamily: 'recoil',
    MsgExecuteContract: 'cosmjs-types/cosmwasm/wasm/v1/tx',
    MsgExecuteContractEncodeObject: '@cosmjs/cosmwasm-stargate',
    Coin: '@cosmjs/amino',
    toUtf8: '@cosmjs/encoding',
    StdFee: '@cosmjs/amino',
    CosmWasmClient: '@cosmjs/cosmwasm-stargate',
    ExecuteResult: '@cosmjs/cosmwasm-stargate',
    SigningCosmWasmClient: '@cosmjs/cosmwasm-stargate',
    // react-query
    useQuery: makeReactQuerySwitch('useQuery'),
    UseQueryOptions: makeReactQuerySwitch('UseQueryOptions'),
    useMutation: makeReactQuerySwitch('useMutation'),
    UseMutationOptions: makeReactQuerySwitch('UseMutationOptions')
};
exports.UTIL_HELPERS = [
    '__contractContextBase__',
];
const convertUtilsToImportList = (context, utils, registeredUtils) => {
    return utils.map((util) => {
        let result = null;
        if (registeredUtils) {
            result = (0, exports.convertUtil)(context, util, registeredUtils);
            if (result) {
                return result;
            }
        }
        result = (0, exports.convertUtil)(context, util, exports.UTILS);
        if (result) {
            return result;
        }
        throw new Error(`missing Util! ::[${util}]`);
    });
};
exports.convertUtilsToImportList = convertUtilsToImportList;
const convertUtil = (context, util, registeredUtils) => {
    if (!registeredUtils.hasOwnProperty(util))
        return null;
    if (typeof registeredUtils[util] === 'string') {
        return {
            type: 'import',
            path: registeredUtils[util],
            name: util
        };
    }
    else if (typeof registeredUtils[util] === 'function') {
        return registeredUtils[util](context);
    }
    else {
        return registeredUtils[util];
    }
};
exports.convertUtil = convertUtil;
// __helpers__
const getImportStatements = (list, filepath) => {
    // swap helpers with helpers file...
    const modifiedImports = list.map(imp => {
        if (filepath && exports.UTIL_HELPERS.includes(imp.path)) {
            const name = imp.path.replace(/__/g, '');
            return {
                ...imp,
                path: (0, exports.getRelativePath)(filepath, `./${name}`)
            };
        }
        return imp;
    });
    const imports = modifiedImports.reduce((m, obj) => {
        m[obj.path] = m[obj.path] || [];
        const exists = m[obj.path].find((el) => el.type === obj.type && el.path === obj.path && el.name === obj.name);
        // MARKED AS NOT DRY [google.protobuf names]
        // TODO some have google.protobuf.Any shows up... figure out the better way to handle this
        if (/\./.test(obj.name)) {
            obj.name = obj.name.split('.')[obj.name.split('.').length - 1];
        }
        if (!exists) {
            m[obj.path].push(obj);
        }
        return m;
    }, {});
    return Object.entries(imports)
        .reduce((m, [importPath, imports]) => {
        const defaultImports = imports.filter(a => a.type === 'default');
        if (defaultImports.length) {
            if (defaultImports.length > 1)
                throw new Error('more than one default name NOT allowed.');
            m.push(t.importDeclaration([
                t.importDefaultSpecifier(t.identifier(defaultImports[0].name))
            ], t.stringLiteral(defaultImports[0].path)));
        }
        const namedImports = imports.filter(a => a.type === 'import' && (!a.importAs || (a.name === a.importAs)));
        if (namedImports.length) {
            m.push((0, utils_1.importStmt)(namedImports.map(i => i.name), namedImports[0].path));
        }
        const aliasNamedImports = imports.filter(a => a.type === 'import' && (a.importAs && (a.name !== a.importAs)));
        aliasNamedImports.forEach(imp => {
            m.push((0, utils_1.importAs)(imp.name, imp.importAs, imp.path));
        });
        const namespaced = imports.filter(a => a.type === 'namespace');
        if (namespaced.length) {
            if (namespaced.length > 1)
                throw new Error('more than one namespaced name NOT allowed.');
            m.push(t.importDeclaration([
                t.importNamespaceSpecifier(t.identifier(namespaced[0].name))
            ], t.stringLiteral(namespaced[0].path)));
        }
        return m;
    }, []);
};
exports.getImportStatements = getImportStatements;
const getRelativePath = (f1, f2) => {
    const rel = (0, path_1.relative)((0, path_1.dirname)(f1), f2);
    let importPath = rel.replace((0, path_1.extname)(rel), '');
    if (!/^\./.test(importPath))
        importPath = `./${importPath}`;
    return importPath;
};
exports.getRelativePath = getRelativePath;
