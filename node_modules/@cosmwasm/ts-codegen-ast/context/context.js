"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenderContext = exports.RenderContextBase = exports.BuilderContext = exports.getDefinitionSchema = exports.defaultOptions = void 0;
const deepmerge_1 = __importDefault(require("deepmerge"));
const path_1 = require("path");
const utils_1 = require("../utils");
const imports_1 = require("./imports");
exports.defaultOptions = {
    enabled: true,
    types: {
        enabled: true,
        itemsUseTuples: false,
        aliasExecuteMsg: false
    },
    client: {
        enabled: true,
        execExtendsQuery: true,
        noImplicitOverride: false,
        useDeclareKeyword: false,
    },
    recoil: {
        enabled: false
    },
    messageComposer: {
        enabled: false
    },
    messageBuilder: {
        enabled: false,
    },
    reactQuery: {
        enabled: false,
        optionalClient: false,
        version: 'v4',
        mutations: false,
        camelize: true,
        queryKeys: false
    },
    useContractsHook: {
        enabled: false
    }
};
const getDefinitionSchema = (schemas) => {
    const aggregateSchema = {
        definitions: {
        //
        }
    };
    schemas.forEach(schema => {
        schema.definitions = schema.definitions || {};
        aggregateSchema.definitions = {
            ...aggregateSchema.definitions,
            ...schema.definitions
        };
    });
    return aggregateSchema;
};
exports.getDefinitionSchema = getDefinitionSchema;
class BuilderContext {
    providers = {};
    addProviderInfo(contractName, type, classname, filename) {
        if (!this.providers[contractName]) {
            this.providers[contractName] = {};
        }
        this.providers[contractName][type] = {
            classname,
            filename,
            basename: (0, path_1.basename)(filename, (0, path_1.extname)(filename))
        };
    }
    getProviderInfos() {
        return this.providers;
    }
}
exports.BuilderContext = BuilderContext;
/**
 * context object for generating code.
 * only mergeDefaultOpt needs to implementing for combine options and default options.
 * @param TOpt option type
 */
class RenderContextBase {
    builderContext;
    contract;
    utils = {};
    schema;
    options;
    constructor(contract, options, builderContext) {
        this.contract = contract;
        this.schema = (0, exports.getDefinitionSchema)(contract.schemas);
        this.options = this.mergeDefaultOpt(options);
        this.builderContext = builderContext ?? new BuilderContext();
    }
    refLookup($ref) {
        return (0, utils_1.refLookup)($ref, this.schema);
    }
    addUtil(util) {
        this.utils[util] = true;
    }
    addProviderInfo(contractName, type, classname, filename) {
        this.builderContext.addProviderInfo(contractName, type, classname, filename);
    }
    getProviderInfos() {
        return this.builderContext.providers;
    }
    getImports(registeredUtils, filepath) {
        return (0, imports_1.getImportStatements)((0, imports_1.convertUtilsToImportList)(this, Object.keys(this.utils), registeredUtils), filepath);
    }
}
exports.RenderContextBase = RenderContextBase;
class RenderContext extends RenderContextBase {
    mergeDefaultOpt(options) {
        return (0, deepmerge_1.default)(exports.defaultOptions, options ?? {});
    }
}
exports.RenderContext = RenderContext;
