"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGettingProviders = exports.createProperty = exports.createIContractsContext = exports.createProvider = void 0;
const t = __importStar(require("@babel/types"));
const case_1 = require("case");
const utils_1 = require("../utils");
const constants_1 = require("../utils/constants");
const createProvider = (name, providerInfos) => {
    const classDeclaration = t.classDeclaration(t.identifier(name), t.identifier('ContractBase'), t.classBody([
        t.classMethod('constructor', t.identifier('constructor'), [
            (0, utils_1.tsObjectPattern)([
                t.objectProperty(t.identifier('address'), t.identifier('address'), false, true),
                t.objectProperty(t.identifier('cosmWasmClient'), t.identifier('cosmWasmClient'), false, true),
                t.objectProperty(t.identifier('signingCosmWasmClient'), t.identifier('signingCosmWasmClient'), false, true),
            ], t.tsTypeAnnotation(t.tsTypeReference(t.identifier('IContractConstructor')))),
        ], t.blockStatement([
            t.expressionStatement(t.callExpression(t.super(), [
                t.identifier('address'),
                t.identifier('cosmWasmClient'),
                t.identifier('signingCosmWasmClient'),
                t.identifier(providerInfos[constants_1.PROVIDER_TYPES.SIGNING_CLIENT_TYPE]
                    ? providerInfos[constants_1.PROVIDER_TYPES.SIGNING_CLIENT_TYPE].classname
                    : 'undefined'),
                t.identifier(providerInfos[constants_1.PROVIDER_TYPES.QUERY_CLIENT_TYPE]
                    ? providerInfos[constants_1.PROVIDER_TYPES.QUERY_CLIENT_TYPE].classname
                    : 'undefined'),
                t.identifier(providerInfos[constants_1.PROVIDER_TYPES.MESSAGE_COMPOSER_TYPE]
                    ? providerInfos[constants_1.PROVIDER_TYPES.MESSAGE_COMPOSER_TYPE]
                        .classname
                    : 'undefined'),
            ])),
        ])),
    ]));
    classDeclaration.superTypeParameters = t.tsTypeParameterInstantiation([
        t.tsTypeReference(t.identifier(providerInfos[constants_1.PROVIDER_TYPES.SIGNING_CLIENT_TYPE]
            ? providerInfos[constants_1.PROVIDER_TYPES.SIGNING_CLIENT_TYPE].classname
            : 'IEmptyClient')),
        t.tsTypeReference(t.identifier(providerInfos[constants_1.PROVIDER_TYPES.QUERY_CLIENT_TYPE]
            ? providerInfos[constants_1.PROVIDER_TYPES.QUERY_CLIENT_TYPE].classname
            : 'IEmptyClient')),
        t.tsTypeReference(t.identifier(providerInfos[constants_1.PROVIDER_TYPES.MESSAGE_COMPOSER_TYPE]
            ? providerInfos[constants_1.PROVIDER_TYPES.MESSAGE_COMPOSER_TYPE].classname
            : 'IEmptyClient')),
    ]);
    return t.exportNamedDeclaration(classDeclaration);
};
exports.createProvider = createProvider;
const createIContractsContext = (providerInfos) => {
    const properties = [];
    for (const key in providerInfos) {
        if (Object.prototype.hasOwnProperty.call(providerInfos, key)) {
            const contractProviderInfo = providerInfos[key];
            properties.push((0, exports.createProperty)(key, contractProviderInfo));
        }
    }
    return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier('IContractsContext'), null, null, t.tsInterfaceBody(properties)));
};
exports.createIContractsContext = createIContractsContext;
let PROVIDER_MAPPING = {};
PROVIDER_MAPPING[constants_1.PROVIDER_TYPES.SIGNING_CLIENT_TYPE] = 'ISigningClientProvider';
PROVIDER_MAPPING[constants_1.PROVIDER_TYPES.QUERY_CLIENT_TYPE] = 'IQueryClientProvider';
PROVIDER_MAPPING[constants_1.PROVIDER_TYPES.MESSAGE_COMPOSER_TYPE] =
    'IMessageComposerProvider';
const createProperty = (name, providerInfos) => {
    let typeAnnotation = null;
    const keys = Object.keys(providerInfos);
    if (keys?.length == 1) {
        const key = keys[0];
        typeAnnotation = t.tsTypeAnnotation(t.tsTypeReference(t.identifier(PROVIDER_MAPPING[key]), t.tsTypeParameterInstantiation([
            t.tsTypeReference(t.identifier(providerInfos[key].classname)),
        ])));
    }
    else {
        const typeRefs = [];
        for (const key of keys) {
            typeRefs.push(t.tsTypeReference(t.identifier(PROVIDER_MAPPING[key]), t.tsTypeParameterInstantiation([
                t.tsTypeReference(t.identifier(providerInfos[key].classname)),
            ])));
        }
        typeAnnotation = t.tsTypeAnnotation(t.tsIntersectionType(typeRefs));
    }
    return t.tsPropertySignature(t.identifier((0, case_1.camel)(name)), typeAnnotation);
};
exports.createProperty = createProperty;
const createGettingProviders = (providerInfos) => {
    const properties = [];
    for (const key of Object.keys(providerInfos)) {
        properties.push(t.objectProperty(t.identifier((0, case_1.camel)(key)), t.newExpression(t.identifier((0, case_1.pascal)(key)), [
            t.objectExpression([
                t.objectProperty(t.identifier('address'), t.identifier('address'), false, true),
                t.objectProperty(t.identifier('cosmWasmClient'), t.identifier('cosmWasmClient'), false, true),
                t.objectProperty(t.identifier('signingCosmWasmClient'), t.identifier('signingCosmWasmClient'), false, true),
            ]),
        ])));
    }
    return t.exportNamedDeclaration(t.variableDeclaration('const', [
        t.variableDeclarator(t.identifier('getProviders'), t.arrowFunctionExpression([
            (0, utils_1.identifier)('address?', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('string')))),
            (0, utils_1.identifier)('cosmWasmClient?', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('CosmWasmClient')))),
            (0, utils_1.identifier)('signingCosmWasmClient?', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('SigningCosmWasmClient')))),
        ], t.objectExpression(properties))),
    ]));
};
exports.createGettingProviders = createGettingProviders;
