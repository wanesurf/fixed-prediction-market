"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAndParseTypes = exports.findExecuteMsg = exports.findQueryMsg = exports.readSchemas = void 0;
const json_schema_to_typescript_1 = require("@pyramation/json-schema-to-typescript");
const fs_1 = require("fs");
const glob_1 = require("glob");
const cleanse_1 = require("./cleanse");
const parse_1 = require("./parse");
;
const readSchemas = async ({ schemaDir, clean = true }) => {
    const fn = clean ? cleanse_1.cleanse : (schema) => schema;
    const files = (0, glob_1.sync)(schemaDir + '/**/*.json')
        .filter(file => !file.match(/\/raw\//));
    const schemas = files
        .map(file => JSON.parse((0, fs_1.readFileSync)(file, 'utf-8')));
    if (schemas.length > 1) {
        // legacy
        // TODO add console.warn here
        return {
            schemas: fn(schemas)
        };
    }
    if (schemas.length === 0) {
        throw new Error('Error [too few files]: requires one schema file per contract');
    }
    if (schemas.length !== 1) {
        throw new Error('Error [too many files]: CosmWasm v1.1 schemas supports one file');
    }
    const idlObject = schemas[0];
    const { 
    // contract_name,
    // contract_version,
    idl_version, responses, instantiate, execute, query, migrate, sudo } = idlObject;
    if (typeof idl_version !== 'string') {
        // legacy
        return {
            schemas: fn(schemas)
        };
    }
    // TODO use contract_name, etc.
    const idl = {
        instantiate,
        execute,
        query,
        migrate,
        sudo
    };
    return {
        schemas: [
            ...Object.values(fn(idl)).filter(Boolean),
            ...Object.values(fn({ ...responses })).filter(Boolean)
        ],
        responses,
        idlObject
    };
};
exports.readSchemas = readSchemas;
const findQueryMsg = (schemas) => {
    const queryMsg = schemas.find(schema => schema.title === 'QueryMsg');
    return queryMsg;
};
exports.findQueryMsg = findQueryMsg;
const findExecuteMsg = (schemas) => {
    const executeMsg = schemas.find(schema => schema.title.startsWith('ExecuteMsg'));
    return executeMsg;
};
exports.findExecuteMsg = findExecuteMsg;
const findAndParseTypes = async (schemas) => {
    const Types = schemas;
    const allTypes = [];
    for (const typ in Types) {
        if (Types[typ].definitions) {
            for (const key of Object.keys(Types[typ].definitions)) {
                // set title
                Types[typ].definitions[key].title = key;
            }
        }
        const result = await (0, json_schema_to_typescript_1.compile)(Types[typ], Types[typ].title);
        allTypes.push(result);
    }
    const typeHash = (0, parse_1.parser)(allTypes);
    return typeHash;
};
exports.findAndParseTypes = findAndParseTypes;
