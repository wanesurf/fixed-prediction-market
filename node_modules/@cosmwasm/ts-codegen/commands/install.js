"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const glob_1 = require("glob");
const mkdirp_1 = require("mkdirp");
const os_1 = require("os");
const parse_package_name_1 = require("parse-package-name");
const path_1 = require("path");
const rimraf_1 = require("rimraf");
const shelljs_1 = require("shelljs");
const prompt_1 = require("../utils/prompt");
const TMPDIR = (0, os_1.tmpdir)();
const rnd = () => Math.random().toString(36).substring(2, 15) +
    Math.random().toString(36).substring(2, 15);
const getPackages = (names) => {
    return names.map(pkg => {
        const { name, version } = (0, parse_package_name_1.parse)(pkg);
        return `${name}@${version}`;
    }).join(' ');
};
exports.default = async (argv) => {
    // don't prompt if we got this...
    if (argv._.length) {
        argv.pkg = argv._;
    }
    // current dir/package
    const cur = process.cwd();
    let thisPackage;
    try {
        thisPackage = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(cur, 'package.json'), 'utf-8'));
    }
    catch (e) {
        throw new Error('make sure you are inside of a telescope package!');
    }
    // what are we installing?
    let { pkg } = await (0, prompt_1.prompt)([
        {
            type: 'checkbox',
            name: 'pkg',
            message: 'which chain contracts do you want to support?',
            choices: [
                'stargaze-base-factory',
                'stargaze-base-minter',
                'stargaze-sg721-base',
                'stargaze-sg721-metdata-onchain',
                'stargaze-sg721-nt',
                'stargaze-splits',
                'stargaze-vending-factory',
                'stargaze-vending-minter',
                'stargaze-whitelist',
                'wasmswap'
            ].map(name => {
                return {
                    name,
                    value: `@cosmjson/${name}`
                };
            })
        }
    ], argv);
    // install
    if (!Array.isArray(pkg))
        pkg = [pkg];
    const tmp = (0, path_1.join)(TMPDIR, rnd());
    (0, mkdirp_1.sync)(tmp);
    process.chdir(tmp);
    (0, shelljs_1.exec)(`npm install ${getPackages(pkg)} --production --prefix ./smart-contracts`);
    // protos
    const pkgs = (0, glob_1.sync)('./smart-contracts/**/package.json');
    const cmds = pkgs
        .filter((f) => { return f !== './smart-contracts/package.json'; })
        .map((f) => (0, path_1.resolve)((0, path_1.join)(tmp, f)))
        .map((conf) => {
        const extDir = (0, path_1.dirname)(conf);
        const dir = extDir.split('node_modules/')[1];
        const dst = (0, path_1.basename)(dir);
        const files = (0, glob_1.sync)(`${extDir}/**/*`, { nodir: true });
        files.forEach(f => {
            if ((0, path_1.extname)(f) === '.json'
                || f === 'package.json'
                || /license/i.test(f)
                || /readme/i.test(f))
                return;
            (0, rimraf_1.sync)(f);
        });
        return [extDir, (0, path_1.resolve)((0, path_1.join)(cur, 'contracts', dst)), dir];
    });
    // move protos 
    for (const [src, dst, pkg] of cmds) {
        (0, rimraf_1.sync)(dst);
        console.log(`installing ${pkg}...`);
        (0, mkdirp_1.sync)((0, path_1.dirname)(dst));
        (0, shelljs_1.exec)(`mv ${src} ${dst}`);
    }
    // package
    const packageInfo = JSON.parse((0, fs_1.readFileSync)('./smart-contracts/package.json', 'utf-8'));
    const deps = packageInfo.dependencies ?? {};
    thisPackage.devDependencies = thisPackage.devDependencies ?? {};
    thisPackage.devDependencies = {
        ...thisPackage.devDependencies,
        ...deps
    };
    thisPackage.devDependencies = Object.fromEntries(Object.entries(thisPackage.devDependencies).sort());
    (0, fs_1.writeFileSync)((0, path_1.join)(cur, 'package.json'), JSON.stringify(thisPackage, null, 2));
    // cleanup
    (0, rimraf_1.sync)(tmp);
    process.chdir(cur);
};
